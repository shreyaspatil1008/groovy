///Java class 

public class Person {
    private String name ;
    private int age;
    
    public Person(String n, int a) {
        this.name = n ;
        this.age = a ;
    }
    public String getName(){
        return this.name ;
    }
    public void setName(String n){
        this.name = n ;
    }
    
    @Override 
    public String toString(){
        return "Person("+this.name+","+this.age+")";
    }    
    public static void main(String[] args){
        Person p = new Person("xyz", 20);
        p.setName("abc");
        System.out.println(p.getName());
        System.out.println(p);
    }
}

//SO same java code works 
//Groovy 
1. Default public 
2. Remove ; 
3. import groovy.transform.* 
4. add 
@Canonical   //generates Hash, toString, equals and tuple ctor 
@Sortable   //compareTo and compareByName etc 
@AutoClone  //.clone()
Remove Tostring, ctor, 
5. Remove private such that this is a property 
   so getName etc are autogenerated , Remove those 
6. make def inplace of  void 
   Remove  System.out.
   Remove ( of println  as args do not need brackets, (no arg needs)
7. make every thing dynamic other than properties 


import groovy.transform.* 

@Canonical   //generates Hash, toString, equals and tuple ctor 
@Sortable   //compareTo and comparatorByName etc 
@AutoClone  //.clone()
class Person {
    String name  //Note def means Object but not comparable, hence must use type, for Sortable 
    int age     
    static def main(def args){
        def p = new Person("xyz", 20) //infers 
        p.setName("abc")
        println p.getName()
        println p
    }
}

//Groovy Magic  
1. Update p.name = "abc" and p.name 
   Implement getSalary and setAddress, with backing field _addr 
   internally updates directly property or  get* and set* 
2. And Follow the code 
   
//Code 
import groovy.transform.* 

@Canonical   //generates Hash, toString, equals and tuple ctor for all properties , not field
@Sortable   //compareTo and compareByName etc 
@AutoClone  //.clone()
@ToString(includeNames=true)
class Person {
    String name 
    int age    
    private def _addr  
    def getSalary(){  //it is present in @ToString
        200            //last line is return 
    }
    def setAddress(addr){
        _addr = addr
    }
    static def main(def args){
        def p = new Person("xyz", 20)
        p.name = "abc"
        println p.name
        println p
        println p.salary
        p.address = "Home"
        println p._addr
        //Other ctor 
        def p2 = new Person(name:"ABC", age: 20)
        def p3 = p2.clone().with{
                    age = 30
                    delegate
                  }
        Person p4 = ["B", 30]
        def p5 = [name: "C", age:2] as Person 
        println("$p2 $p3 ${p3.salary} $p4 $p5")
        //add @ToString and check again 
        @groovy.lang.Newify([Person])
        def p7 = Person("N",2)
        def p8 = Person.new("D", 3)
        println "$p7 $p8"
        //Create list 
        def lp = [p,p2,p3,p4,p5,p7,p8] 
        def lp2 = lp.clone()
        //Sorting capibility 
        println( lp[0] > lp[1])  //from Sortable 
        println(lp2.sort())//inplace 
        //copy , and with closure 
        println(lp.sort(false){ e -> e.age }) //sortBy, closure arg  should be different than local scopeed variable
        //OR 
        println(lp.sort(false){ it.age }) 
        //with salary 
        println(lp.sort(false){  e -> e.salary })
        //get all names using spread 
        println( lp.sort(false).reverse()*.name) //spread
        println( lp.sort(false).reverse().name) //GPATH   for property      
        println(lp.sort(false, Person.comparatorByName())*.toString()) //if method, apply spread
        println(p.class.methods.name)
        //Safe navihgation and elvis 
        Person pp 
        println(pp?.name)
        //or 
        def ppx = pp ?: "It's a null"
        println(ppx)
      }
}


///Let's find out the difference between 

//1.Groovy is always Ref type and inferred 
int i = 1 
Integer i2 = 1 
def i3 = 1 
println "${i.class} ${i2.class} ${i3.class}"

//No Char literals , use below 
'A' as Character 

//suffix G for BigInt and by default BigDecimal
def i4 = 1G 
def f = 1.2 
println "${i4.class} ${f.class} "

//by default java.io, java.util, java.net, java.lang 
//groovy.lang, groovy.util, java.math.bigdecimal,bigint are imported 

//2. Few difference 
//== content checking , is for Identity checking 
"HELLO" == "HELLO"

//All objects can be 'coerced' to a boolean value: 
//everything thatâ€™s null, void, equal to zero, or empty evaluates to false, and if not, evaluates to true.
def lst = [] 
if( !lst)
    println "Empty"

//Comparison operators are null safe 
String s = null 
assert i != 2 


// do..while is not supported 
//do {
//} while (s == null)
//but while is OK 


//Groovy supports calling one parameter without giving the parameter 
def f(x){ println x}
f()  //null
f(2)  //2 

//Groovy supports optional arg , default arg , keyword based arg 
def f(x=2){println x}
f() //2
f(3) //3 
f(x=2)
def f(m) { println m} //m is map 
f(x:2, y:3)

//Groovy array literal 
//java 
int[] array = { 1, 2, 3}
//groovy
int[] array = [1,2,3]



//Groovy does not support protected as package scope 
//for that use 
@PackageScope class Bar {      // package protected
     @PackageScope int field    // package protected; not a property
     @PackageScope method(){}   // package protected
 }



//static  inner class fully supported 
class A {
    static class B {}
}

new A.B()
//Annonymous inner class fully supported 
import java.util.concurrent.*

Timer timer = new Timer()
timer.schedule(new TimerTask() {
    void run() {
        println("executed")
    }
}, 1000)  //ms delay 
//But Syntax changed of inner class 
//java 
public class Y {
    public class X {}
    public X foo() {
        return new X();
    }
    public static X createX(Y y) {
        return y.new X();
    }
}
//groovy 
class Y {
    class X {}
    def X foo() {
        return new X()
    }
    static def X createX(Y y) {
        return new X(y)
    }
}

def y = new Y()
y.foo()
Y.createX(y)




//3.Groovy is dynamic typed(runtime type) 
//In java , selection based on static type of variable 
public Integer compute(String str) {
    return str.length();
}
public String compute(Object o) {
    return "Nope";
}
// ...
Object string = "Some string";          
Object result = compute(string);        
System.out.println(result); //Nope 
//in groovy , selection based on infered/runtype type 
int compute(String string) { string.length() }
String compute(Object o) { "Nope" }
Object o = 'string'
def result = compute(o)
println result  //6 


//4. method invocation is dynamic (ie reflection based)
//if @groovy.transform.CompileStatic is not used 
def  str = "Hello World"
String.metaClass.upper = {  delegate.toUpperCase()}
println("${str.upper()}")
//ERROR: runtime metaprogramming is disabled and String#upper is not found 
@groovy.transform.CompileStatic
def f(){
    def  str = "Hello World"
    String.metaClass.upper = {  delegate.toUpperCase()}
    println("${str.upper()}") 
}
f()

//5. We can write Extension methods in groovy 
//Global extension methods are technical name of GDK 
//Global one can be written by configuring(under src/main/resources ) META-INF/services/org.codehaus.groovy.runtime.ExtensionModule
class StringExtra{
    static def upper(String self){
        self.toUpperCase()
    }
}
use(StringExtra){
    println "Hello".upper()
}

//6. Write TCO 
@groovy.transform.TailRecursive
def sum(lst, acc=0G){
    if ( ! lst)
        acc 
    else 
        sum(lst[1..<lst.size], lst[0]+acc)
}

sum((0..10000).toList())

//7.Use Extensive GDK methods 
def outputFile = new File('groovy.html')
def url = new URL('http://www.google.co.in')
// Saving textual content.
outputFile.delete()
outputFile.text = url.text

//No ARM syntax in Groovy, Use GDK methods which would do ARM 
new File('out.txt').eachLine('UTF-8') {
   println it
}

//8. Use enhanced Switch 
//switch(a){case b : } means b.isCase(a)
def check(value){
    switch(value){
        case "abc" :  println("abc"); break
        case BigDecimal :  println("BigDecimal"); break 
        case 10..20  : println("in range");break 
        case [1,2]  : println("in list");break 
        case [ok:1,nok:2] : println("in map");break 
        case  ~/Hello/  : println("regex");break
        case  { it == "World"} : println("closure");break 
        default : println("default")
    }
}
check("abc")
check(2.3)
check(13)
check(1)
check("ok")
check('Hello')
check("World")
check('A' as Character)


//9. Can overload operator 
class Operator implements Comparable<Operator>{ //comparable is needed for compareTO
    def getAt(index) { println("o[index]")}
    def plus(other)  { println("o1 + o2")}
    def putAt(index,v) { println("o[index]=v")}
    def isCase(value) { println("in");true}
    def asType(Class t) { println("as")}
    int compareTo(other) { println("<=>"); 1} //return type should be int 
    def call(Integer...args ){ println("fn, args is list")}
}

def o = new Operator()
def o2 = new Operator()
o <=> o2 
o[2]
o[3] = 2
o + o 
3 in o 
o as String 
o <=> o 
o(1,2,3)




//10. Change the closure searching dynamically via delegate 
class Person {
    String name
}
def p = new Person(name: 'Norman')

def upperCasedName = { name.toUpperCase() }    //use delegate.name.toUpperCase()
upperCasedName.delegate = p    
println(upperCasedName())

//11 write DSL 
void sendEmail() {
    email {                                //email(Closure)
        from 'das@mycompany.com'           //Closure.delegate = Someclass , use Closure.rehydrate(Object delegate, Object owner, Object thisObject) method 
        to 'somebody@waitaminute.com'      //set Closure.resolveStrategy = DELEGATE_ONLY such that only delegate is searched 
        subject 'Groovy is good'           //from, to, subject, body are methods of that class taking single argument
        body "Hello there"
        attached "file.name"
    }
}

def email( Closure code){
    def esp = new EmailSpec()
    def nc = code.rehydrate(esp, null, null)  // Copy a Closure with new delegate, owner, this by  rehydrate(Object delegate, Object owner, Object thisObject)
    nc.resolveStrategy = Closure.DELEGATE_ONLY
    nc()
}

class EmailSpec {
    def from(String from) { println "From: $from"}
    def to(String to) { println "To: $to"}
    def subject(String subject) { println "Subject: $subject"}
    def body(String text) { println text }
    def methodMissing(String methodName, args) {
            println("${methodName.toUpperCase()}  ${args.join(",")}")
    }
}

sendEmail()
    
///12. Use many builders 
//eg JsonBuilder , for Json
import groovy.json.*
//Array by ,
def builder = new JsonBuilder()
builder.car {
        name 'HSV Maloo'
        year 2006,2007,2008
        country 'Australia'
        record {
            type 'speed'
            description 'production pickup truck with speed of 271kph'
        }
  }

def json = builder.toPrettyString()
//reading is easy 
def obj = new JsonSlurper().parseText(json) //or .parse(java.io.File)
//Use HOF - filter - findAll(cl) , map-collect(cl), flatMap-collectMany(cl) , reduce-inject(z)(cl), zip- lisOfList.transpose(), 
//enumerate- .withIndex().collect { element, index ->} , foreach - each(cl), groupBy(cl) 
obj.car.year.findAll{it > 2002}.collect{it*2}

//OR XMLSlurper
import groovy.xml.*
def writer = new java.io.StringWriter()
def xml = new MarkupBuilder(writer)

xml.car {                                    // each closure creates sub section
          name 'HSV Maloo'                  //each method becomes xml tag
          year{
              value 2006
              value 2007
              value 2008
              }
          country 'Australia'
          record ( [type:'speed'] ){
            description 'production pickup truck with speed of 271kph'
            }
        }

def str = writer.toString()
def node = new XmlSlurper().parseText(str) //.parse(java.io.File)
node.name  //node is car 
//each node iteration, ie car then name then year then value, value, value, then country ...
node.'**'.each { n -> println(n.name()) } //.text(), .attributes()


///13. Existence of trait(interface with default) and Runtime mixing and SAM 
trait Greet {
    //abstract String name() 
    def greet() { println "hello $name" }  //default 
}

class Person{ 
  String name
}

def pg = new Person(name:"XYZ")
def pg1 = pg.withTraits Greet    //,T2,T3  //order from right  
pg1.greet()

//SAM coercion possible for trait or interface or abstract class having one abstract method 
def g1 = { println "New Hello" } as Greet
g1.greet()

//for multiple method use map coercion
def f(x) {
 [ hasNext: { -> true } , next : { -> x }] as Iterator<Integer>
}

def c = 0
for(e in f(2)){
     println(e)
     c += 1   
     if ( c == 10) break
}
//OR 
f(2).take(10).each{println(it)} //lazy 